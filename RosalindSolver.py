from typing import Dict, List, Tuple


class RosalindSolver:
    """Class for solving 'Rosalind' bioinformatics problems.
    Each method represents each Rosalind problem.
    """
    
    DNA_BASES = ('A', 'C', 'G', 'T')
    DNA_WC_PAIR = {'A': 'T', 'T': 'A',
                   'C': 'G', 'G': 'C'}
    CODON_TABLE = {
                "UUU" : "F",      "CUU" : "L",      "AUU" : "I",      "GUU" : "V",
                "UUC" : "F",      "CUC" : "L",      "AUC" : "I",      "GUC" : "V",
                "UUA" : "L",      "CUA" : "L",      "AUA" : "I",      "GUA" : "V",
                "UUG" : "L",      "CUG" : "L",      "AUG" : "M",      "GUG" : "V",
                "UCU" : "S",      "CCU" : "P",      "ACU" : "T",      "GCU" : "A",
                "UCC" : "S",      "CCC" : "P",      "ACC" : "T",      "GCC" : "A",
                "UCA" : "S",      "CCA" : "P",      "ACA" : "T",      "GCA" : "A",
                "UCG" : "S",      "CCG" : "P",      "ACG" : "T",      "GCG" : "A",
                "UAU" : "Y",      "CAU" : "H",      "AAU" : "N",      "GAU" : "D",
                "UAC" : "Y",      "CAC" : "H",      "AAC" : "N",      "GAC" : "D",
                "UAA" : "Stop",   "CAA" : "Q",      "AAA" : "K",      "GAA" : "E",
                "UAG" : "Stop",   "CAG" : "Q",      "AAG" : "K",      "GAG" : "E",
                "UGU" : "C",      "CGU" : "R",      "AGU" : "S",      "GGU" : "G",
                "UGC" : "C",      "CGC" : "R",      "AGC" : "S",      "GGC" : "G",
                "UGA" : "Stop",   "CGA" : "R",      "AGA" : "R",      "GGA" : "G",
                "UGG" : "W",      "CGG" : "R",      "AGG" : "R",      "GGG" : "G"}

    def __init__(self):
        pass
    
    def count_nuc(self,
        seq : str
        ) -> Dict[str, int]:
        
        """Count A,C,G,T nucleotide from input DNA sequence.

        Parameters
        ----------
        seq : str
            Input DNA sequence

        Returns
        -------
        Dict[str, int]
            Count of A, C, G, T
        """

        ## init dictionary for counting        
        nuc_counts = {nuc : 0 for nuc in RosalindSolver.DNA_BASES}
        for nuc in seq.upper():
            try:
                nuc_counts[nuc] += 1
            except KeyError:
                continue
        
        print(f'[Input]: {seq}')
        print(f'[Output]:', end=' ')
        for nuc in RosalindSolver.DNA_BASES:
            print(nuc_counts[nuc], end=' ')
        print()

        return nuc_counts
    
    def transcribe(self, dna_seq : str) -> str:
        """Transcribe DNA sequence to RNA sequence.
        (It does not consider the direction of molecule, only replace 'T' to 'U')

        Parameters
        ----------
        dna_seq : str
            Input DNA sequence

        Returns
        -------
        str
            RNA sequence from input DNA
        """
        
        rna_seq = dna_seq.replace('T', 'U').replace('t', 'u')
        print(f'[Input]: {dna_seq}')
        print(f'[Output]: {rna_seq}')
        return rna_seq
    
    def complement_strand(self, seq : str) -> str:
        """Get reverse complementary sequence of input sequence.

        Parameters
        ----------
        seq : str
            Input DNA sequence

        Returns
        -------
        str
            Sequence of complement strand
        """
        
        comp_seq = ''
        for nuc in seq:
            comp_seq += RosalindSolver.DNA_WC_PAIR[nuc]
        comp_seq = comp_seq[::-1]
        
        print(f'[Input]: {seq}')
        print(f'[Output]: {comp_seq}')
        
        return comp_seq
    
    def cal_rabbit_pairs(self,
        n : int,
        k : int
        ) -> int:
        
        """Predict # of rabbit pairs at n th generation in case of reproducing k offsprings
        (implemented by tabulation, bottom-up).
    
        Recurrence Relation
            Fn = Fn-1 + 3 * Fn-2

        Parameters
        ----------
        n : int
            generation number
        k : int
            offspring number from a reproducable pair

        Returns
        -------
        int
            # of rabbit pairs
        """
        
        ## tabulation
        prev_rabbits, curr_rabbits = 1, 1
        for _ in range(n - 2):
            prev_rabbits, curr_rabbits = curr_rabbits, curr_rabbits + k * prev_rabbits
        
        print(f'[Input]: {n} th generation, {k} offspring from a pair')
        print(f'[Output]: {curr_rabbits} pairs')
        
        return curr_rabbits
    
    def _cal_rabbit_pairs_v2(self,
        n : int,
        k : int,
        cache : Dict[int, int]
        ) -> int:
        
        """Predict # of rabbit pairs at n th generation in case of reproducing k offsprings
        (implemented by memoization, top-down).
    
        Recurrence Relation
            Fn = Fn-1 + 3 * Fn-2

        Parameters
        ----------
        n : int
            generation number
        k : int
            offspring number from a reproducable pair
        cache : Dict[int, int]
            Storage containing previous solutions (key: n, value: num_pairs)

        Returns
        -------
        int
            # of rabbit pairs
        """

        ## find from cache
        if n in cache:
            return cache[n]
        
        ## base case
        if n < 3:
            cache[n] = 1
            return cache[n]
        
        ## recursive case
        return k * self._cal_rabbit_pairs_v2(n - 2, k, cache) + self._cal_rabbit_pairs_v2(n - 1, k, cache)
    
    def cal_rabbit_pairs_v2(self,
        n : int,
        k : int
        ) -> int:
        
        """Print input, output of _cal_rabbit_pairs_v2.
        
        Parameters
        ----------
        n : int
            generation number
        k : int
            offspring number from a reproducable pair
            
        Returns
        -------
        int
            # of rabbit pairs
        """
        
        num_pairs = self._cal_rabbit_pairs_v2(n, k, dict())
        print(f'[Input]: {n} th generation, {k} offspring from a pair')
        print(f'[Output]: {num_pairs} pairs')
        
        return num_pairs

    def get_highest_gc(self,
        fasta : str
        ) -> str:
        
        """Get sequence ID and GC ratio which has the highesst GC(%)
        from input fasta file.

        Parameters
        ----------
        fasta : str
            Path of input fasta file

        Returns
        -------
        str
            Seq ID and GC ratio
        """
        
        ## initialize variables
        id_max_gc, max_gc = '', 0
        
        fasta = open(fasta, 'r')
        ## initialize variables
        seq_id, seq = '', ''
        for line in fasta:
            if line[0] == '>':
                ## sequence id line
                if len(seq) == 0:
                    ## if no seq, reset directly
                    seq_id = line[1:].strip()
                    seq = ''
                    continue
                
                ## save previous sequence information
                gc_count = seq.count('G') + seq.count('C')
                gc_ratio = round(100 * gc_count / len(seq), 6)
                
                if gc_ratio >= max_gc:
                    id_max_gc = seq_id
                    max_gc = gc_ratio
                
                ## reset
                seq_id = line[1:].strip()
                seq = ''
            else:
                seq += line.strip().upper()
        fasta.close()
        
        ## sequence id line
        if len(seq) != 0:
            ## save previous sequence information
            gc_count = seq.count('G') + seq.count('C')
            gc_ratio = round(100 * gc_count / len(seq), 6)
        
            if gc_ratio >= max_gc:
                id_max_gc = seq_id
                max_gc = gc_ratio
        
        answer = f'{id_max_gc}\n{max_gc}'
        print(answer)
        
        return answer
    
    def count_point_mutation(self,
        seq1 : str,
        seq2 : str
        ) -> int:
        
        """Count point mutation between s, t sequence.
        (equals to calculate 'Hamming' distance)

        Parameters
        ----------
        seq1 : str
            Input DNA string 1
        seq2 : str
            Input DNA string 2

        Returns
        -------
        int
            Number of diff nucleotides
        """
        
        hamming_dist = 0
        for s, t in zip(seq1, seq2):
            if s != t:
                hamming_dist += 1
        
        print(hamming_dist)
        
        return hamming_dist
    
    def cal_prob_with_dominant_allele(self,
        k : int,
        m : int,
        n : int
        ) -> float:
        
        """Calculate the probability where an offspring of any two organimsms
        has dominant allele.
        (k : homozygous dominant, m : heterozygous, n : homozygous recessive organism)

        k : int
            Number of homozygous dominant organisms
        m : int
            Number of heterozygous organisms
        n : int
            Number of homozygous recessive organisms
        
        Returns
        -------
        float
            Pr(offspring has dominant allele)
        """
        
        prob = 0
        total = k + m + n
        
        ## 1. homo dominant
        prob += k / total
        
        ## 2. hetero
        prob += (m / total) * ((k/(total - 1)) + ((3/4)*(m - 1)/(total - 1)) + ((1/2)*(n)/(total - 1)))
        
        ## 3. homo recessive
        prob += (n / total) * ((k / (total - 1)) + ((1/2)*(m/(total - 1))))
        
        print(prob)

        return prob
    
    def translate(self, rna : str) -> str:
        """Translate mRNA sequence to protein sequence
        (find ORF and translate with ORF).

                      (ORF)
                        |->->->
        ACGUACGUACGUACGUAUGAAACCCGGGAUGACGUUACG... (mRNA)
        
        Example
        -------
        >>> solver = RosalindSolver()
        >>> solver.translate('AAUGAUGAUGAUGUGAAAAAA')
        MMMM
        
        Parameters
        ----------
        rna : str
            mRNA sequence for translation
            
        Returns
        -------
        str
            Protein sequence translated from input mRNA
        """
        
        ## find first 'AUG' sequence (ORF)
        start_idx = rna.upper().find('AUG')
        template_rna = rna[start_idx:].upper()
        step = 3
        protein = ""
        for i in range(0, len(template_rna), step):
            codon = template_rna[i:i+3]
            try:
                amino_acid = RosalindSolver.CODON_TABLE[codon]
                if amino_acid == "Stop":
                    break
                protein += amino_acid
            except KeyError:
                break
        
        print(f'{protein}')

        return protein
    
    def find_motif(self, motif : str, seq : str) -> List[int]:
        """Find motif sequence from input sequence.

        Time Complexity
        ---------------
        O(n*m)
            n : length of seq
            m : length of motif
                    
        Parameters
        ----------
        motif : str
            Motif sequence
        seq : str
            Template sequence

        Returns
        -------
        List[int]
            Indices motif sequence
        """
        
        motif_indices = []
        for i in range(len(seq)):
            subseq = seq[i:i+len(motif)]
            if subseq == motif:
                motif_indices.append(i+1)
        
        for idx in motif_indices:
            print(idx, end=' ')
        print()

        return motif_indices
    
    def find_consensus(self, fasta : str) -> str:
        """Find the most common sequence (consensus) from input fasta file.
        
        (input sequences)
        A T C C A G C T
        G G G C A A C T
        A T G G A T C T
        A A G C A A C C
        T T G G A A C T
        A T G C C A T T
        A T G G C A C T
        | | | | | | | | 
        5 1 0 0 5 5 0 0 (A)
        0 0 1 4 2 0 6 1 (C)
        1 1 6 3 0 1 0 0 (G)
        1 5 0 0 0 1 1 6 (T)
        | | | | | | | |
        A T G C A A C T (Consensus)
        
        Parameters
        ----------
        fasta : str
            Path of fasta file

        Returns
        -------
        str
            Consensus seqeucne
        """
        
        import os, sys
        sys.path.append(f'{os.path.dirname(__file__)}/pkgs')
        # from pkgs.FASTA import FASTAProcessor
        import pkgs.FASTA as fa
        
        proc = fa.FASTAProcessor(fasta)
        proc.open()
        
        ## generator func
        gen = proc.readline()
        
        ## first sequence
        _, _, seq = next(gen)
        
        ## initialize profile matrix with zero
        profile_mat = [[0 for _ in range(len(seq))] for _ in 'ACGT']
        
        BASES = ['A', 'C', 'G', 'T']
        BASE_INDEX = {'A': 0, 'C': 1, 'G': 2, 'T': 3}
        for idx, base in enumerate(seq):
            profile_mat[BASE_INDEX[base]][idx] += 1
        
        for _, _, seq in gen:
            for idx, base in enumerate(seq):
                profile_mat[BASE_INDEX[base]][idx] += 1
        
        consensus = ""
        for i in range(len(profile_mat[0])):
            max_idx, max_count = 0, 0
            for j in range(len(profile_mat)):
                base_count = profile_mat[j][i]
                if base_count > max_count:
                    max_count = base_count
                    max_idx = j
            consensus += BASES[max_idx]
        
        print(consensus)
        for i in range(len(profile_mat)):
            counts = ' '.join([str(count) for count in profile_mat[i]])
            print(f'{BASES[i]}: {counts}')
                    
        return

if __name__ == '__main__':
    def main():
        ## test script
        solver = RosalindSolver()
        # solver.count_nuc('ACGTACGT')
        
        # dna = 'CTTCGAAGTTCATGAGATTCTTCGGACGCCCTCGCTTCATTCGGGCGAGTGTAGAAGAGACGCGCGTGAGATGCTGTAACATAAGATTACGCCTTGTCTGGGTAAGACAGGCGCTATTGGTGGCTGCCGCCGATGGTGTGTACCATCCGTCTTGGAACAATCTGTACAACGTTAACTGTAAGCGGGAATGCCCTAAACGGCGTGACCACTCACATAGACCAGAACGTCTTGCTGGGCCGACCCAGGATCGCTGAGATACGTGAGACGTACGGGAGTAGCACTCTTACGCCGTTGGAAACCATCATTTGCTTGATAACTCGATTGCAATGCGCAGACGCTATTCTCCCACGACCTGATACTAGTGACGTCAGGAGTTAGCTAATAAGCTTGGGTTTGATGTACTTGGGACATGTCTTTAGATTCATTTATCCATGGCTGTCGCATAAAAGTGGTTTTTAACTGAGTAGACTAAGACGTGCGGGGTTAAGAATTTTTCGCCAAAGATGCCGCGAAGCTCGGTGAGACAATCGAGAGTCGTGTGCTGGAACGTAAGCAGCGGCCCACCTGGCGTCATCGACAGGGCGGTCATGCAACCCGTGTTCCTATATACCCGCGTGGCAGACGAGCGTTATCATACTACTTATAACTGTGGATTTACGACTTGCAGAGATTCTGGAGTCGTTCAATACCTATTGATGCGATAAGACAGCTAGATGCAGTGAACCATATTGTACTGGTAAACCTTCTGCACTTAGGATACAGCACCCAAATTACCTTAGACAATCTTACATCTAAATGCATAGCTTTAAATGTATCGCGTGTTTAGATCATGTAGTGGCCAACCCAAGACATCAAGGTAGACACGCTCGCTCGCGCACCTTCGCCCGACACCAACCCTGAGATCTCAGGGCAGGAAGCAAGACGAACGCCTTTTAC'
        # solver.transcribe(dna)
        
        # dna = 'ATTCGTGGCTCTGGGGCCCGCGGATAACTGTAATGGCGAAATTGCGGACTATGACCCTGTTATCTAATCACAAAAACGGCGCTAGAAGTGACCCAGAATGTGTGCTGATCCGAATACATCTCACAACAAGTTTACCGCAACGCAACGGGCTTTGCGCTTTTCTAATGATTTGAAGACCGTGGCGAACATTGGCCTAATTACCCACTCTAGTTAATCCCAGACACTGGGGTCTCCAGCGACAGTAAGTCCAGTACATGAGACCAATCTACCAAGTGGTTGGGCACGGCGGTGGAATTACCTCCTCCTTGATCATTACTTTTGACTAATAGCTGTTCGAATTGTAAGCACGCAGGAGTGGCCTGGACGGAGTGTCCGATGCAGTTCGTGACGCCCCTTACGTACTAAGATCGTGGTTAATTCGTGGGATTTCAAAGGAATGGTGTGGTTCTTAGAACTGTCCCAGCCACGTTGGAGGTGCATCTGAATCTCTAGACGGGCCATATTCGGCCAATAGGAATAATCCCCGGGCTTCCTTCTTTAAAGCCACAAGGAGTTAGTAAGGGGGGAGCTATGATCGGTAAGTACGGCGTCCCCGAGGTGGTATCGAAACCGGATGTAACCATATCATCATTGTTATTGACATACGCTGTACTTTATACCAATCTCTCTTGCTCTAAGCGGTGATGTATAGTATATCGCCTCATTCACTGCTGTGACACGGGGAACCTTTGCCAAGCGTACGGTACCTGTAGGAAGTCGAACGGCGTACCGCAGAGCCCAGATCTACGTGCTAGGGCAAGGATATTCCCAGGTTACCAGCAGCATTAAGACTCCGGTATCGCAGAGTCTGCTTTGTCCAACCCGTCCTCGAATTGGTCAAGGCTTGGGTCGCTAGCTCTCGGACGTGTAGCCACTCCCTTTAGACTTTCCAGGTTCCAGCTGCCACGCAAAGCTCACCTCGCCAACCCA'
        # solver.complement_strand(dna)
        
        # n, k = 33, 5
        # solver.cal_rabbit_pairs(n, k)
        # solver.cal_rabbit_pairs_v2(n, k)
        
        # solver.get_highest_gc('/Users/hanbeomman/Downloads/rosalind_gc.txt')
        
        # seq1 = 'AGGGGAGGCCCGACAAATGCCAAACTTATGCATATGGTTTTTCCGAGCACTACGATCTCCGCTCCAGTGCGAATCTCTGAGTACGAGTATTCCAGGTCAGACTCGCATCCTTAAACGCTCCGATGACCGATTATGTCTAATGTTTAAAGGCAATCGCTGTAGATAACCACCTTTAAAAACCAGACATGGGTACTGCGCAGTCCGTAGAATACCGTTCGTGATAGTGCATGTTTCGGTCCACCTACGGTCATCCGCGTCCGGAGGCAAGGTTATGACCACACCCTGTATCGTAACAGGGTGAATGCCAATAGTAGCGGCACTTCTCATGCCACCCGTGTCCGGCGCTTTGCTATGTACTTCACCGCTTAATTCCAAACGGCAGAGGGGTTCGCCCTGGGAAGGTTCTTCCAATACATCACATTTTGCCAGAGAGTTGGCACTCGTAGGTTGTGTCAAGAGTCCTTTGCGGGTTCGGAGCCGATAAAAGTCATGGCTCCTCTGTATCTTCTCGATCTGGTTCGTTATGAGTATATGATGTGAGTTTGGCATTAAAGTAATTGGTTAGGATTACCTGAAGCGTCCAGATCTTGCATTTCCCACTTACATGAATAATGTCCAATTTTACGGCGCGTACCCATGCATTTACAAGCACGTTTTGCCTTAATTGATATTTCAAAGAAGCCCTAGATGTCACCTAGTAAGGACCTAGCCTTATACACGTTATAAATGTGTTTCTTTGCTTATAAGTACGTCCATCAAATCCTTTCCCTGTGATGCCATCGTCATGACGCTTGATCCGCCCTGTCCTTCGTACATGTACGATCCCGACGTGGCCCTCTTCTTAGGGTGTGCTGCAAATATGGTTCCCGACTGCCCTCCGCGACGAACGAAACGTTTCCCCTCCTAACACTCCAGGTCCCGTGTAAGAACAGCGCGCCCTGAAGCATAATTTGCCACGGCCTTTCGCTTCCCTGTTGCTTATA'
        # seq2 = 'AGTGGAGGCGCGACGTGGATCAATGATTTGGATTGGATTGTTAGGTCCTCATGCGAGTGCGCGGGTTGAAGATGCACTAAGGTCCGCTATGCCAGATCAGACTCGGCTTCTTAAACGGTCCGATGACCCCTTAAAGCTTCAGATTAAGGGATAGTGTTTTATATATTCACCTGTACCACCCAATGATGGGTCATGCCGATTCCCTACCTTAACGTTTTATAGAGAGGCCGCTAGGAAGTTACGCCGACCTTCCCAGCTATGAGAAATGATCCAGTAGCGGCCGGTTATCCTCCACGGGTTCTCGGCGGTGGTGTAGGGTTATCAGAAGTCCCTAAAAGCCTTTCGATTGTTGTGTATCTCACTACGCCATCCTATACCTTTACAGACTTGGCGACAGTAACTATCGCCCCGTACATCACTTTGAACAAGGGAGACGGCGATGGTAATCTATGCACATTGTCCCGATCCGGTTCCGTTCCTATGGAGGTCCTGGCGAGTCATTAGATTCGTTATCTGGTTTGTCATGGGTAGACGATTGTACCCGGCTTTTTAATGTTTCCCTATGGTGTACCGCAGGCTGCCAGTTCAGTCGTCTGGTCATTCAATGCATAGAGGGCAAGCTGACCGCGCGCATCTATGTGCTTCATAACCCCTCGGCGCTTCAGTCCTGGTACGGAGAAGACCTAAGATTCACCTACAAGGTACCCAGCCTGAAAATGGTGTTAAGAGAGTATATCAGCTTATAAGTTTGTTCATTAGTTCGTTTCCCTATGCTTTCGTGGTGCTGACGAAAAGTCCGGCCCCTCACCCGAACTAGGATGTGCCCGTCGTGGTCACCTGCATATGGGTAGTAATGCCCGGGTGTTCCGATTAAACGCCGCGATCAACGGTACTGACCCTGTTCCAAAACTGCGATACCACTGACCAATGAGCACACCAGGTAGCAAACTTACCCACGACGGCTCGTTCATGCATTACCTACT'
        # solver.count_point_mutation(seq1, seq2)
        
        # k, m, n = 17, 29, 16
        # solver.cal_prob_with_dominant_allele(k, m, n)
        
        # rna = 'AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA'
        # rna = 'AUGACUGUGCUGGACCCUAGCAGGUCGCCGAAUAGCAGUUUAAUGCGGUCGUGCGCAGGUGUGGCCGAGAGGAUUACCAUGUGUGCCUUGUUGCGAAUACGUGACUUAUAUGAGGGCCCAGUGAUCGCUUACGAAGUCGCAAUGAUCGCCCUCACCAUUGGGUUUUUCCCAACGGUGCAGCAAAGCCUGGGGACCUCCCCGAGUGUUGUACGCUCCACAUGCACUCUAAAUUACGAGGGUCAGACGAGGCAGCGCUACGACAUACACGGCAGAUUGAAAAUUUCAUACCGGUCCUUCUCGCGUACUGGAUCUCAUGUCUUUGCCCCUCACUUGGAGUCCCGAUCUUUAAUUCGACCUGAGUGUUUUCGAAGAUGGUACCUAUUACGCAACAAUGACUCCCCUAACAGGUAUGACCGCUACCCAACCAUGUCCUCCAGACCUAGCCGAAAGCGCCUUUAUCGUCUCUUUGAGCUUCGACAUGGACGCAGAACCACCAAGUCUCGUAGGAAAUGCGCUUCUCGUAGCUCUACGCGCGAAGAAAUCCCGUUAAAGGGUACAAGUCUGUGUGGGUGCGCCAGGGAGGGGUACUUGCUUCCUCGACCGAGACGCCCGGCUCACAAGUCGUUGCACCAGGCACGACUUGGCACUUUGCAAAUCCCCGUGGGUCGACGCUUUCCCAGCACGUAUAUCGGGUCCAAGGACAUAAUAACUUUGUUCUUAUGGCCACUAUGGUACGGCCUGUUUAAACCGCCCAGAGACAUCCUGCGAAUAACUCGAGAGCACCGUACCUUCUUUGAACCUAGCGCAGCAAAAUCUGAUUGCAGGAUUCUUCGUGUUACCAAUUUAAAGCGUAACGGACUCGCAGAUUUGAACACUCGUCUGCGGCUCAAGACACCCAACUCGAAGGCGUGUGUAGCAGUCGGCGUACCUGCUCGCCCCGGGUCCGGGAGAAUGCUGCGACGUGCGGGUCGUGAGAGCUGCACGCUAGCCACAUUGACCUGGUCCCCGCCAGCCCUAAAACGUGGGUGCGCAAGCGUGCCCACCAAAUACAGACUGUCUUGUAUGUUGCAGACAAAGAAAUUUAAUCGCCCUCUUAGCUCAGUCCAACAUUUAACGGCUUUAGGUGAAUCGGCGAACUGUGCGGCACAAACAAGAUCGAGCUUAGUAGGGUCACGGCCAAUACGAUUUCAAUACCGCCCAUCUGCGCUAACCGUAACACGCAAGAAGGGGAGAUACGUUUCCUCCGCCGACCAAGCCACGCGUUCGCUCGAUGAAAGCGCAACGCACAUUGACGCCGAGUCCUCCUCCGGAACUGAUUCUAAGGAGUUCUGGACUGGCGUACGUAGUACAAAGCGAGGUAAGAUAUCGGCCUGGGUCCAUAGUGCCCCGGGAUACCUGGAGUUAGGUGACUUAUUUCGAUCUAUGAAUUCCAACAUCGUACGGCCCAGUGCCCUGGGUGGGACUUCUCCGCUUGGACUUCCGACUGUAGCUGAAAAGGCCAGGCGCACCACUAAAAGAUCCCCUAAAUUACUCUGGUUGGAUACAAAUAUGGGAUGUAAAGAGUUACUCGUGACGUUAGUACCUGCUGUUCUGCACGCUACUGUUCCUGGUAGACUCGCCGCACAGGUAUUCGUAAGGUGUAAAUUGGAACAGCUCCGGCGUAGGAACUCAAACGGAGGUCCCCAUUCGGAAGGCCACCGAAGGACCCAGUUCGGAUGGAGCGUAGUAAGAAAAGCAAUACCUUACUGUCUGGGCCUUGUAGCUCGCAUACCUACUGUACUGGAGGACGACCACUUAAUGAACGUGGAGGGGCUUAUUACGUCACCUCACUCAACUCAGGCGAUCGGCGCGAGAUCAGGGCCUCACACCCAGGGAGUUCAAACCUUUCACGUUAACCCAUUUAGAUGCCAUACGUGUCCGGAACACGAUAAAUCGAGGCCAGGUCGGCCUUGGCAUAUCUUCGGGUGGGAAUGCCAACGCCUUAUCAUACCUAUUCCAAGGCGUCUCGAUUACGUGGUACCGGCAACCCUCAGUAGGCUCGCCCAUAUACACGGCGCAUUAUGGGCAAGAGCUUACUUAUCAGGCCCUAUUAAUCCACACCCUACCAUAGGAAGUGAGACAUUAAGGCUGUACGAGUAUUGGAAAAUAUGCACGGCUAUGGAUAGAGUGAACACCCCACCCUACCCUUAUAUUGACAUUGCGAAUAGAAGACGUUUGCCUUCACCUCACACCACGAUGCGUUUCCCGUGGAGUUGGUUCUUGCUGAUGCUCUUACUAAACUCUUCCUUUGGAGCCGGAACAACUCCUCAACCGAUGUCCAAGACAGUAGUACGCCGUGCCAUUAUGGCAUUUUUCCAUCACUCAUACCAAGCUUCACCCACUCAUGUUUGUGUGUGUUCGUCAUAUGUGCCCCCGAAACCUAAUGCAAAAAAAUAUCUUGAUGGAGAGGCAACUUGGCUUCGGGAGGGGAAUCCUUGGGACGACCUUGAGCGGAACUGGAUACGCGGUACAGAAAAAACCAUAAUCAAAAACUGGGAUCAUGAUGCUCUUGGUACCAAAGCAGCACCAUUUCAGCUGCUCUUCUCUGUAAGGUUCGGCUGGAACAAAGUUGUCACCUAUCAUGCAUCAAAAGGUUUCCUUCGAUUGAAGCUCAAUUAUUGCGGAUACGGCAUCGGGGUAGUUGACUGGGCAGAGCACAAUAGUGGGCCAUUGGAUGUCACAGAAUUUGCGUUAGGGACUCUCAUGGCUCCCGAAAGUAUUCAAGGUCUACGAACGCAGGCGCCCUCGUUCAAUCCAACGAAUAAGGUGUGCAUCUAUAUUUCACGGUGUCAAACCUUUGCAGUGUGCCAUCACUGGCAUUCGGGCUGGUCACUACGUUUCUCUGGAGAUCAACGGUCCCGAAGCCUGCGAUGUACCUUCUUCGCGCCAUUGUGGCCACCGGGGAGCUGUUCAGAUCACGAAGUAUCUGGUCUGGGCGUAGUGCGUAGCAUCAGCGAGAGCGAACCGCAAAUAGGGCGGCUUAUACCUCGUUGCGCAACCAAGAGAAACCAAUCUGCUCGUGUAAUGAUGUAUAUAAAGAGAAUUGAGGACCAGACCCGUGUUCAGGGUCUAUUUCCCACAAGAUGGCACAGGCUGUCGGAACGAAAGCUAUCUCGAUUGUUGUCCCCCCUUGCUACCACUAGGUUAAAACCGAUAUGCAUCCGGCUGGCAAAUGUUGUCCCCAAGUAUCCACCCAAUAUAAUCUUUAAUGGGAUUCUCCAUGCGCCUGAGUCAGAAGUAUCCUCAGACGCUUUACGAGAAUCCCACCGGCUGAACUAUUUUGUCUCCGCUAGAAAAGGGCUGCUAAGGUUGAGCCCAGCAAGCGCCAGAAACCUUUGGCGACCCGCCGAGAAGGACGAAAGCGGUAUGAGAGCGAUUUCCCCGCCAAUCAGCUGUGCCUUUCGUUCGGAAUGCUAUUGGUUGCCGCCUGGCGUAGUCUAUGGGGUCCGUAACACUCGGCCUCUUUUUGCCCUAUGCGAGGAGUCGAUAGCGAAAGCCAUCUCACACGGAGUUUACUUCUCAUCAGUGCUGCGACCCAUACAUGAGAUCCAGGCUGAUAAAGACUCUCGAGGCAAGCAUACAUGGGGCGUAUUUCUUGUAAUCCGAAUCGUCUCCUGUGCAUGUAUAUUCUUUGCCGACGAGCACGGAAUGCCAGGGAUUGAACACCUUCUAACCGAGAGAAUCCAUCAUUUGUACGCAUCCGGGUGUCCCUUACAGAUGCCUGUUAACGCCGCGAUACUUCUACAUUUUGAACUUCAUACUCGUGGGACUCCCUGUGUCUGGGUCCACGCUCCGGAAAUGCGCCUACUGGGGGUGAUGCACUCGGUCGAGGCCGGCGAGCCUACUCGCUACGAAUGCAGUAACACCGCUAGCUAUUUCCUGCCCUGGGCGUCGCCCCGUAUGACAAGUUACUCAUGGAAAAACAUACAAGUCUUGCGCGGGCUUUGUGCCGCCUCGGUGAACUCUCCGAAAGUCGCAGGACACGUGUACUGGGAGGUCGGUUGUCUAGAAUGUUUCACAUCGUCCCAAUCAGACGUAAAUGUCGUGCAUGAGAAGGUAUGUUGUACAAGGACAGGGAAAUACAUCUGUAAGAGACGGUACUAUCUCGUUCCCUGGACACUUACCAGUAACGGCACCGGCUCGGUGUGCCCAAACCAAGCGGCGUCAGAACCGAAUGUCUUUCGCCGACACUCCGCAAAAACUGGAAAAUUAGAGUUUAGCUAUACCACCGAGGUUAGCCUCGUGGACCCUGUUGCUAGGAUGGAGUCCGUUUUGCAACCUCUUCUCUGCACUAUCCGAAUUCGCGAAGACCACUUUCGCGCGCAAAAUGUCGGGGCGAGCGUCCAGGUUGCCCGACCCUCCGCGCAGUCAGAACCUAGUCAAUCUGGAAAGAAGGUGAGCAACAUUUUAGACCUCGAGAGACGAAUUUGUUCCGGAAUACGCUUCACCACGCUCGUAAACGACGGAAGUGCAGCAUUAGGGUUGGUACGUCAAUGGCGCUGCUCUACCAAUAUGUUUAAGCUUGAGGAACAUCAACGGGAGGUGAUGGACGAGGACCCUCUCCUCACACGCAUGUACCCGUUCGCUAAUCUGGCGUACCAGCGGAUCACUUGCCGACGCCUGUAUAUACUCAACGCUUACUUCGCAUCUCAUAUUCGUACGCGCCACUUCGGUUUACCCGAUCUUCUGUUGUCAGUGAGGCCGGUAGUCAGGAGCUCUAGGUCGGUAAAGGUCUUAAGAAAUAAGGUCAAUGGCCAGUCGUUUAGUCACAAAGUACCAGCGGCAUUGACGACCAGCCUCGUGCCCUCAUGUCGUGGUGCAUUAGCGGUAUACAUGGCAACCGCUUCGGUGCUCAUACCUAGUUCAGCGCGCGGGCAGAGAGUUAAGCCAAACGGUGAGAAAAAAUACCCUGAUAACACUGAUCGCGCCAUAACCUGUUCCCGGUCGUUAACUCGUACGACUUCACGUUUUCUAUUAAACAUUUCUGUGCACACCCCACAAGUUGGAAUCAUCACUUCAAUAUGGCAGAUUAUUUACAGCGCUCCUGUUUCGGCUAUAACCUUCUAUUUGGUGCGUCUAGGUUAUACUAAUCCGGCGACCAUCGAUCCAUCAUUUUGCAACUAUCUACUAAGCCAAACUCCUUACCCACUCCCCCUGAGAGAGCUGAAUAGAGUAACAUCCUUAUCGUACCAUCAAAAGCAAGUACUUCUGACCUAUUCACAAGUCUUACAUUACGCAAGAGAUAUCCAUCCUACUCUCAGUACAACGCCCUACGGCAUGGCCCGCGUAGGAUCCGGCUCCGUGGAUCGGCACUUAGUUAAGGGGUCAUGUUCGGAUAAAAAUGUGGGACAGGGAAAUCUAUGUGCAUUAUGUGUGACUUUUCGACCUCAUGUCGGUGAUAUCUUGUAUGAAUCUACAAAUUUUUGGCACGUCACGGCUUCAUCGUGGUUGAAAUACCUAGAUAAAGCCUUGCCAGAGAGACUUAGUUCACGAUGGGAGUACGUUUAUAACCGCAGUUAUCACCCCAACUCCAUACGUCCUCGAUCUUGCCCUGCUACAGUAGCCAGUGGUCGUUCCAACUCAGUCUUAGCGACAGCCCAUAGUGUUACAACCUACAUAUCCGCAGAUUACUGGCACCACUAUACCGGGAAGCUGUCUGCUGGUAGUACCCACUUGAAUCAUUCUUUUCCCCGGGCCGAGAGCGUAUUACCGAGUCGUUGGAGCUGCUGGUUGCGAAUCCGUCUACUCUCUGACUGGCUGGGCGCAAACGACCGCUUUUUCCGCGGAAGGUGCGGAGUUUCACGGUUUCUGGGAAAAGCACCGUUAAUAGCUAUCACAACUAGGUACGGGGGUGUGAUAGACUCUCAAUCAGCCACUGAUAGACGCAAAUGGCCAUACAAUUGCGGGGCAUCUUGUGCCCGUAGCACAGUUUUAGACCGACCACAACCCAUGUGUGGUCUGGCUCAAUUCCUAGUACUGGUUUUAAAUGACAAGAACCGGAGUGGGAAUCCAACCCCAUGGAGGUCUUAUAUCACUAGCAUCAGAGGCGAUGCGCUAAGACCCUAUCUGGUUCAUCAGCCUUUGGCAGACCAAGUGAACGUGAUUUGGAGUAGGUCGCUGCUGUCCUCGAGAAUUCUAUAUGGCUUUUUCUUUCAACUGAAGCGAAACGCAAUCAGGACUCUGAGGCCGUCCGUAAAAUUCCACAGAGAAUGUGAGCAUUAUCCUCGGACAGAUAGAGCGACUCGUGUGGCAGGAUGUGAAGCCGCCGUGCCCCAGGAGCAAACCAAAGACCUUACCAGCCGUUGCAACGGACCGCCGCGUUUGGCCGUAGAGAUAGUUAGUCCUUUGCACAACGAUGUCUGUAAACAUAUGCCGAACUGUGAGUUCCUAUUUUCAUGGAAUAUAUACUUUAUGGUUACUGACAUGCAGACUAGGAUUAGAACGAUGAGGCAAGGGUUCGUAAUGACCCCCUCCCAUUCCAACAUGAUGAUAAUUUACAACAGGGUUCCGCGCCACGUCCGAAAACUCCUCGCUCAUGUAGCUAGUGCUCUCUCCAUGCCUCAUUGCUGUCCAGCACAAGGGUCGCGGUACGGCGCACUAAACUCCUCCCUGACGGCUCGGCAUGUGGCUACGAGAGUGAUGUGCAAGGAAGCUCAAGGUCAAUGUUUAUCAAAUAUAGAACCCCAUACGGCCCUAAGGAACUUCUCUCUUCUACCAGAGCCAUAUACACUGAGGUUGUCUGCGUUGGAUCCUUGGUCUCUUAAACCCAGGAGAUACUUCUUACCUAGCGGGCAGGCGUCUCACUCCCUACAAUCCCUCUACACUCGCUGUGUUGCCAUACCAACGCGAUCAGGACCGGCAGGUGCCGCUAAUCAUGUCCUUUGUAUGCUCCGACGAGUCCGUGAAACCCGUUGUCAGCUGCGAAAUUUAUUGCAGUCCAUCCUCUUGCCGGACCAUUACCCGACGAUCCAUCCAUGGACGCUCUUCUAUGUUAUGAUACCUGGAACACUGGCACUAGGGAAAGAGUCGGAUUCCCGGAUCACGACAAGGAAGAGCGCCAAUUGGCAAACAGCUCUGAUUCAUAAGAAAGUAAAUCAGUCACCACAUGUGAUCACUUUAGCCGCGAAGAUUUAUUAUGCACCUUUAAGCGCCAGGACCCCCCCGGCCUGCCGAGGUUGGACCACCGUUCGCGAACUCACCCAGUCGCUAGGGACUUACCAAAGUGAACAUGCAGAAAUCUAUACAGCUACGCAGAAGUGUUACUCAGGGUUGAAGCCUAAGCGCCUGAAGUCUAGUUUACUGUGCUGCUAUGUAGCGACUCAACGGCCUUAUCGAGCUGUAGUAAUACUGAACUUCUGCAGGUUCCGGCGAAGUCACCGACACUACAACGCAUCGAAGUGUUCGAGAGAUUACGGAAUUGCUACAGAGUACUAUGCUGGCAAAGACCCGUCGACUUUUCCGCCAAGGGCGCGAGGUAAGAUUAUCUAUCGAUUAAGCUAUCUGGAAUACCAACGUAGGCGUCUGUACUUCCUUAAUUGGCCAGGACCGUCAGUUUCUCACCAUUACGAAAUUAAAUAUCACCGAAACAUCAUGCCUGUGUCAGUUUCCACGCGCAGCCCCUGGGAGGUUUCAAGAUACGCCUUCCUAUCAACUUACCCCUCAAGUAGCAUUGUCCUAAACUGGCUCGCGUGCAACACGACCGUCGGGAUCCCGCCUGACCACAUGAGCACUAUAUAUUUCCCUUUGUACAGCAGCCCGCUAAGUAGCAAGGCCCACUCGAUAGGGCGAAGGGGGCGAGACCGGACUCGGAGCUGCACACAAGUUUCCGAAGCAGCGUCGAAUCAUCACACAAAGGGCCCCCUAGUCACUACUGAUUCUAGCCGCUGGUCACACGUUAUGCAGCAUAAGGGCACUGCGAGGCAUAAUCAGUGUGGUAGAGGACUACUCCGGGGAAACGCUCAGAUAAUGAGCGUGUGCCCUUUCCUGGCGUGUAAGUGCGUUAUCAAACUACCACCGCCAUGGUGGCUCGCAUCUUCAAGGCCGACACUUAUCCCAAACCUCCCACGAGGCUUCGAAUGUCUCGCCUCUUCACAGGGUGAUCUUAUAACUUGCAGAUAUCGGCCCCAAACUGGGCGGACGAGCGACGGAUUUACGGCCUGCCACCCGGCCUACACAACAGUUGCGCGCUCCUGCAUGACUGGUCCAUCAGUUUCUUAUUCGCGCCAUCUGAGCCUAUGCAUCGCGGUUGCACACUGCGCUACGCGUCCUGGGUUUACCAGGUUGGCAGCCAUGACCCUGGGCAGAGCCCAAUCUGUAGCGCGAUUUCUUCAAUUGUUCUUAAGUGGACCAUACGAGGCUGAUACACAGUCACAGUAUAAGAAUUGUGGCUCUACACCUUCUGGUACUGCCUGGUAUCUGCUUAACGAACGGCCAAAUGUCAAAACGAACCGCAAGUCACAGAGGCCUAGCCAGGCUAUGUUGACGAACCCGAAGGGACGAGCACAAUGUCGUUUAUAUUUAAUGAAGAGCCUGCACCGGAUCCUCCUUCAGUUCGACGAAAGUAGAUUAUGCGUAUCCCGUAACAAAGUAUCCAGCCCUUAUCUCCUCCGCGGAACUGCCGCUCAAGGACUUUAUUCCGGAUUUUGUAUAGCAAUGACCCGAGAGAUGCUCUUCGGGAGCGAGGCGUGGGUAGACGCCUUCGGGCAUGCCGGGUGCAGGACCAGCCCUAGAGCUGACCUACGCGGGCUCUAUGCAUCAGGGAGGAUCAAAUCUAUCCUGCACAGCGUACAAGGCCGUGACCUACUUACUGCAAUUAAGGCAAUUUACCACGGCGCCCUCUAUGCCACGGAACAAUACGCGAUCGACAAUCGUCGAUGGAUAUCCAACUGGACAAAUGUAACAAUGAUAAAACUCUGUAGGAUGUCCAGUAAGGCCUUUCCUGGAUGGCGCUUCAAUUUUUCGACGAGUCGCCUGACUGCCAUAACGUUGGGUAAUAAAGGGCAUACACUAGCAACCCGACUCGUCAUGUCUGGAGGGACCGACGUAUCCGUUCCACCGUCCUCCAUGUUUCCCUUCCCUACUCCGCUCGCAAGAUGCCUUUGCUGCCGCUACCGAACGACUCCGGCUAUAGGGCCCCCGUGGAAUUGGUGCGCACUACUGGUCUUCGGUUUGUCGCAACUCCCCCGAUUAAGCUUUUAUGGUACACAUAAAAAUGAUGCAUACGUCAAACGCGGAAAUAUACCUUACCGGUAUAAAGGCCUUACCGUUCUCAACCCGAGUACUGUACAACAUUUUGGGAAACCUGUGCUGCACGUCGUCGUUCGAAAACAUCUCUCCGAGGAACCAAGACCCUUCGAAGUAGGAGGCCAAACAGCUAGGUGGGUCCGGGAGCCAAACAGCGUGAUGGCCCUGACACGUGCUAUGAAAAAAGAAGGAUUGACCUCGCGUAUCCGCGUGGGAGAUUAUAAACAGGGGGCCACGAUUCCUGUUUCUGCAACUUUUAACUAUUUGCCACAGCCCGGAAACGCUCCAUCGGCUCCUCUAAAAGUUCGUGGUCCUUAUUACGAGAGGAUAGUCACAGACCCUCCUAUAGCGGGUAAGCGUUCAUCUAGAGCGUCCUUACAAAAAUACCAAUUUAUCGGACUUCACUCCCACUUGGACUUUACCGCUGGUCAAAGGCUCCGUUAUCGUAAGAACCGCCCAGUCUGUUUUGUGUUCCAUCAAGGCUUCACGUAG'
        # sol = solver.translate(rna)
        # print(sol == 'MAMAPRTEINSTRING')
        
        # seq = 'CCAGGCTGTACAGCTGTACGCTGTACGGGCTGTACCATACGCTGTACACCCGGCTGTACTAACTACCTGCTGTACCGCTGTACCGCTGTACGCTGTACGCTGTACGCTGTACCGGTGCTGTACTGCTGTACTGCTGTACGCTGTACCGCTGTACGCTGTACCCTATCGGGGCTGTACTGCAAGCTGTACATGCTGTACATAGCTGTACATGCTGTACGGCTGTACCAGCTGTACGTAGCTGTACGATACACCCGGCTGTACGCTGTACAACGCTGTACGCTGTACACGGCGGCTGTACAGCTGTACCGCTGTACCTGCTGTACGCTGTACGGCTGTACCAACGCTGTACTGGCTGTACCATCAACAGGCTGTACTGCTGTACTGCTGTACGCTGTACCCGCTGTACACAGCTGTACGGGTGCTGTACAGCGCTGTACGCTGTACGCTGTACGCTGTACTCCAAGCTGTACATCGCTGTACGCTGTACGTGCCGCTGTACTAGCTGTACGCTGTACAAAGGGCTGTACCGGGGATCGCTGTACGGCTCAAACGCTGTACGGCTGTACTGCTGTACTCTGCTGTACAGCTGTACGCTGTACGCTGTACTCGGCTGTACCTCGTGCTGTACCGGCTGTACGCTGTACGCTGTACGCTGTACGGCTGTACCCGCTGTACGCTGTACGCTGTACAGCTGTACGGCTGTACAATAGCTGTACTCTGCTGTACGGGCTGTACGGGGAGGCTGTACGCTGTACATAGCTGTACGCTGTACTAGCTGTACATGGCTGTACCTTCTAATAGCTGTACACGGCTGTACATAGCTGTACAGCTGTACCAGGCTGTACAGCTGTACTGCTGTACGTCCAGAGTGGCTGTACTGCTGTACTATGCTGTACAGCTGTACGGCTGTACGCTGTACGAGCTGTACAGGCTGTACGTGCTGTACCT'
        # motif = 'GCTGTACGC'
        # solver.find_motif(motif, seq)
        
        fasta = '/Users/hanbeomman/Documents/project/rosalind/test.fasta'
        fasta = '/Users/hanbeomman/Downloads/rosalind_cons.txt'
        solver.find_consensus(fasta)
        
        
    main()